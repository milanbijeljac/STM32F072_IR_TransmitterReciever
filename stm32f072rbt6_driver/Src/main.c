/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* **************************************************
 *			    	INCLUDES					    *
 *************************************************  */

#include <stm32f072x8.h>
#include <cortex_m0_config.h>
#include <stm32f0xx_gpio_driver.h>
#include <sys_adc.h>
#include <sys_frequency.h>
#include <sys_timer.h>
#include <NEC_transmission.h>
#include <TemperatureCalculation.h>

/* **************************************************
 *					DEFINES 					    *
 *************************************************  */

#define CHECK_TEMP_UPPER      0u
#define AC_POWER_ON       	  1u
#define CHECK_IF_AC_IS_ON 	  2u
#define CHECK_TEMP_LOWER	  3u
#define AC_POWER_OFF		  4u
#define CHECK_IF_AC_IS_OFF	  5u

#define UPPER_TEMP_THRESHOLD  28.0f
#define LOWER_TEMP_THRESHOLD  23.5f
#define DEBOUNCE_UP_THRESHOLD (sint8)15u

/* **************************************************
 *			    FUNCTION PROTOTYPE 					*
 *************************************************  */
extern void initialise_monitor_handles(void);
static void GPIO_Config(void);

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/****************************************************/

static void GPIO_Config(void)
{

	GPIO_v_PeripheralClockControl(GPIOB, ENABLE);
	GPIO_v_PeripheralClockControl(GPIOA, ENABLE);

	GPIO_PinConfig_t GPIO_PinConfiguration;

	GPIOx_v_GPIOCfgStructClear(&GPIO_PinConfiguration);
#if (CAPTURE_MODE == STD_ON)
	/* Pin used as an input for IR receiver */
	GPIO_PinConfiguration.GPIO_PinNumber = 12u;
	GPIO_PinConfiguration.GPIO_PinMode = FALING_TRIGGER;
	GPIO_PinConfiguration.GPIO_PinPuPdControl = PULL_UP;

	GPIO_v_Init(GPIOB, GPIO_PinConfiguration);

	/* Interrupt configuration */
	GPIO_v_IRQInteruptConfig(IRQ_EXTI4_15, ENABLE);
	GPIO_v_IRQPrioConfig(IRQ_EXTI4_15, 1u);

	GPIOx_v_GPIOCfgStructClear(&GPIO_PinConfiguration);
#endif

	/* Analog pin configuration - used for temperature sensor */
	GPIO_PinConfiguration.GPIO_PinNumber = 1u;
	GPIO_PinConfiguration.GPIO_PinMode = ANALOG_MODE;

	GPIO_v_Init(GPIOB, GPIO_PinConfiguration);

	GPIOx_v_GPIOCfgStructClear(&GPIO_PinConfiguration);

	/* IR transmitter configuration. AF2 == TIM2_CH1_ETR */
	GPIO_PinConfiguration.GPIO_PinNumber = 0u;
	GPIO_PinConfiguration.GPIO_PinMode = ALTERNATE_FUNCTION_MODE;
	GPIO_PinConfiguration.GPIO_PinAltFunMode = AF2;

	GPIO_v_Init(GPIOA, GPIO_PinConfiguration);

	GPIOx_v_GPIOCfgStructClear(&GPIO_PinConfiguration);

	/* USART2 Tx configuration. AF1 == USART2_TX */
	GPIO_PinConfiguration.GPIO_PinNumber = 2u;
	GPIO_PinConfiguration.GPIO_PinMode = ALTERNATE_FUNCTION_MODE;
	GPIO_PinConfiguration.GPIO_PinAltFunMode = AF1;

	GPIO_v_Init(GPIOA, GPIO_PinConfiguration);

	GPIOx_v_GPIOCfgStructClear(&GPIO_PinConfiguration);

	/* USART2 Tx configuration. AF1 == USART2_TR */
	GPIO_PinConfiguration.GPIO_PinNumber = 3u;
	GPIO_PinConfiguration.GPIO_PinMode = ALTERNATE_FUNCTION_MODE;
	GPIO_PinConfiguration.GPIO_PinAltFunMode = AF1;

	GPIO_v_Init(GPIOA, GPIO_PinConfiguration);

	GPIOx_v_GPIOCfgStructClear(&GPIO_PinConfiguration);
}

int main(void)
{
    initialise_monitor_handles();

	uint8  u_acState           = CHECK_TEMP_UPPER;
	sint8  u_debounce          = 0u;
	uint16 u_adcValue          = 0u;
	uint32 u_powerOnCodes[3]   = {0xFF00FF00u, 0xFF00AB54u, 0x1BE454ABu}; /* No timer, horizontal swing, fast speed, 23 degrees C cooling */
	uint32 u_powerOffCodes[3]  = {0xFF00FF00u, 0xFF00EB14u, 0xFE0154ABu};

	float  f_tempOld      = 0.0f;
	float  f_temperature  = 0.0f;

	/* 16 MHz frequency */
	PLL_Enable(RCC_CFGR_PLLMUL4);

	UART_v_Init(16000000, 115200);

	TIM3_v_cfg(16u);

	GPIO_Config();

	ADCx_u_Init(ADC1, 9u);

	TIM2_v_IrFrequencyCfg();

	while(1)
	{
		#if (CAPTURE_MODE == STD_OFF)
        switch (u_acState) {
			case CHECK_TEMP_UPPER:

				  u_adcValue = ADCx_u_Read(ADC1);
				  f_temperature = Temp_f_CalculateTemperature(u_adcValue);
				  Delay_v_ms(100u);

				  if(f_temperature > UPPER_TEMP_THRESHOLD)
				  {
					  u_debounce++;
				  }
				  else if(u_debounce != -127)
				  {
					  u_debounce--;
				  }

				  if(u_debounce > DEBOUNCE_UP_THRESHOLD)
				  {
					  u_acState =  AC_POWER_ON;
					  u_debounce = 0;
				  }

				break;
			case AC_POWER_ON:

				NEC_v_SendMessage((uint32*)u_powerOnCodes, sizeof(u_powerOnCodes) / sizeof(u_powerOnCodes[0]));
				u_acState = CHECK_IF_AC_IS_ON;

				break;
			case CHECK_IF_AC_IS_ON:

				u_adcValue = ADCx_u_Read(ADC1);
				f_tempOld = Temp_f_CalculateTemperature(u_adcValue);

				Delay_v_seconds(60u);  /* Wait 6 minutes and check if temperature drops. TODO: Change this logic */

				u_adcValue = ADCx_u_Read(ADC1);
				f_temperature = Temp_f_CalculateTemperature(u_adcValue);

				if(f_temperature > f_tempOld)
				{
					u_acState = AC_POWER_ON;	/* AC did not receive signal correctly, send signal again */
				}
				else
				{
					u_acState = CHECK_TEMP_LOWER;
				}

				break;
			case CHECK_TEMP_LOWER:

				  u_adcValue = ADCx_u_Read(ADC1);
				  f_temperature = Temp_f_CalculateTemperature(u_adcValue);
				  Delay_v_ms(100u);

				  if((f_temperature < LOWER_TEMP_THRESHOLD) && (u_debounce != 128u))
				  {
					  u_debounce++;
				  }
				  else if(u_debounce != -127)
				  {
					  u_debounce--;
				  }

				  if(u_debounce > DEBOUNCE_UP_THRESHOLD)
				  {
					  u_acState =  AC_POWER_OFF;
					  u_debounce = 0;
				  }

				break;
			case AC_POWER_OFF:

				NEC_v_SendMessage((uint32*)u_powerOffCodes, sizeof(u_powerOffCodes) / sizeof(u_powerOffCodes[0]));
				u_acState = CHECK_IF_AC_IS_OFF;

				break;
			case CHECK_IF_AC_IS_OFF:

				u_adcValue = ADCx_u_Read(ADC1);
				f_tempOld = Temp_f_CalculateTemperature(u_adcValue);

				Delay_v_seconds(60u);  /* Wait 6 minutes and check if temperature drops. TODO: Change this logic */


				u_adcValue = ADCx_u_Read(ADC1);
				f_temperature = Temp_f_CalculateTemperature(u_adcValue);

				if(f_tempOld > f_temperature)
				{
					u_acState = AC_POWER_OFF; /* AC did not receive signal correctly, send signal again */
				}
				else
				{
					u_acState = CHECK_TEMP_UPPER;
				}

				break;
			default:
				u_acState = CHECK_TEMP_UPPER;
				break;
        }
		#endif
	}
}
